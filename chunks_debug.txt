<chunk>
```html
<h1>Introduction to Operating Systems</h1>

<p>Welcome!</p>
<p>Speaker Notes: ON SCREEN</p>

<p>Welcome! In this lecture, we will look at a brief history of operating systems. We will look at how they evolved over the years in parallel to the evolution of the hardware that they run on.</p>

<p>[CLICK – Next Slide]</p>

<h2>Goals</h2>
<ul>
<li>Describe generations of<br>operating systems and their influences</li>
<li>Analyze effects of <br>multiprogramming vs. uniprogramming</li>
<li>Identify components and central abstractions of OS</li>
</ul>
<p>Speaker Notes: ON SCREEN</p>

<p>By the end of this lecture, you should be able to: [CLICK]</p>

<p>Describe the generations of operating systems and their influences; [CLICK]</p>

<p>Analyze effects of multiprogramming vs. uniprogramming; and [CLICK]</p>

<p>Identify components and central abstractions of OS</p>

<p>[CLICK – Next Slide]</p>

<h2>Terminology</h2>
<dl>
<dt>Algorithm</dt>
<dd>A set of instructions with finite initial store and state, a starting point, and unambiguous ordering until the endpoint (halt)</dd>
<dt>Flow chart / pseudocode</dt>
<dt>Program</dt>
<dd>The sequence of instructions that embody an algorithm</dd>
<dd>Source  Assembly  Machine Code</dd>
</dl>
<p>Speaker Notes: OFF SCREEN</p>

<p>But first, let’s look at some terminology. [CLICK]</p>

<p>Algorithm: A set of instructions with finite initial store and state, a starting point, and unambiguous ordering until the endpoint (halt point).</p>

<p>Can be represented by a flow chart or a pseudocode. [CLICK]</p>

<p>Program: The sequence of instructions that embody an algorithm. It can be the Source code or Machine Code.</p>

<p>[CLICK – Next Slide]</p>
```
</chunk>

<chunk>
```html
<h2>Terminology</h2>
<dl>
<dt>Process</dt>
<dd>A program in execution</dd>
<dd>Program + process state (current instruction, state of memory / resources)</dd>
<dt>Job</dt>
<dd>A task to be completed</dd>
<dd>Often a program (or collection thereof) awaiting execution or a process during execution</dd>
</dl>
<p>The words “process” and “job” are often used interchangeably in practice, but they are slightly different.</p>
<p>!</p>
<p>Speaker Notes: OFF SCREEN</p>

<p>Process: a program in execution Program plus, its Process State. These are represented by the current instruction, state of memory and resources. [CLICK]</p>

<p>Job: a task to be completed.</p>

<p>Often a program or a collection of programs awaiting execution. A “job” can also be a process during execution. [CLICK]</p>

<p>The words ‘process’ and ‘job’ are often used interchangeably in practice, but they are slightly different.</p>

<p>[CLICK – Next Slide]</p>

<h2>Why Do We Need an OS?</h2>
<p>How to load a program<br>onto a computer?</p>

<p>Mini-toggle switch per bit in<br>the data register</p>

<p>Mini-toggle switch per bit in<br>the address register</p>

<p>Button to load data from<br>register into memory</p>
<p>Altair 8800</p>
<p>Speaker Notes: OFF SCREEN</p>
<p>Why do we need an OS? For example, to load a program onto a computer.</p>

<p>So, how to load a program onto a computer?</p>
<p>The OS helps us with repetitive or complex tasks that we want to achieve with a computer. For example, loading a program can involve a series of precise but repetitive tasks such as loading data from main memory to a register. [CLICK]</p>

<p>The Alteir 8800 is an example of an old computer that did not have an Operating System. Programs had to be loaded manually before execution. Even to run a simple program involved a series of tasks to be accomplished manually by the operator/programmer. Let’s watch a video of how the Altair 8800 works.</p>

<p>[CLICK – Next Slide]</p>

<h2>Altair 8800</h2>
<p>Video team, please play the following video in its entirety: <a href="https://youtu.be/EV1ki6LiEmg">https://youtu.be/EV1ki6LiEmg</a></p>

<p>If the quality is high enough, please play full screen. If not, please insert the video into this slide.</p>
<p>Speaker Notes: OFF SCREEN</p>

<p>[PAUSE FOR A COUPLE OF SECONDS THEN CLICK TO NEXT SLIDE]</p>

<p>[CLICK – Next Slide]</p>
```
</chunk>

<chunk>
```html
<h2>Why Do We Need an OS?</h2>
<p>How to Load a Program<br>Onto a Computer?</p>

<p>Mini-toggle switch per bit in<br>the data register</p>

<p>Mini-toggle switch per bit in<br>the address register</p>

<p>Button to load data from<br>register into memory</p>
<p>Altair 8800</p>
<p>How to Access I/O<br>Devices?</p>

<p>Uniform interface: <br>Use the same read and write routines</p>

<p>Safety: <br>Restrict access to<br>read/write routines</p>
<p>What About Running<br>Multiple Programs?</p>

<ul>
<li>Manage resources</li>
<li>Protect private info</li>
<li>Facilitate Interactions</li>
</ul>
<p>Speaker Notes: OFF SCREEN</p>

<p>The OS also helps accessing I/O devices</p>

<p>The OS provides the user with a uniform interface to access input and output devices. It often standardizes input and output routines. [CLICK]</p>

<p>The OS also provides a layer of safety. It restricts access to read/write routines to users and process. This keeps users or processes from accessing resources that they shouldn’t, which can disrupt the function of the entire operating system. [CLICK]</p>

<p>What about running multiple programs?</p>

<p>The OS also Manages resources, Protects private information, and Facilitates Interactions between multiple users, processes, and programs. In modern OSs, we are used to multi-tasking: write an email, while glancing at the web browser and listening to some music. The OS makes sure all these programs and tasks are accomplished for the user.</p>

<p>[CLICK – Next Slide]</p>

<h2>Where Does It Fit?</h2>
<p>(Adapted from Tanenbaum & Bos, 2015)</p>
<table>
<tr>
<td>User interface program</td>
</tr>
<tr>
<td>Operating system</td>
</tr>
<tr>
<td>User mode</td>
</tr>
<tr>
<td>Kernel mode</td>
</tr>
<tr>
<td>Software</td>
</tr>
<tr>
<td>Hardware</td>
</tr>
</table>
<table>
<tr>
<td>Web browser</td>
</tr>
<tr>
<td>Email reader</td>
</tr>
<tr>
<td>Music player</td>
</tr>
</table>
<p>Speaker Notes: ON SCREEN</p>

<p>But where does the OS fit in the organization of a typical personal computer system?</p>

<p>The OS is the layer of software that exists between the hardware and the user-interface program.</p>

<p>While the user-interface often seems to be part of the OS, it is not. It is one of the programs that it helps to execute for the user.</p>

<p>This is more transparent, for example, to Unix/Linux users that are used to changing user interfaces, while it may seem stranger to Windows or Mac OS users, that cannot choose between different user interface programs.</p>

<p>[CLICK – Next Slide]</p>
```
</chunk>

<chunk>
```html
<h2>What Is the <br>OS’s Job?</h2>
<ul>
<li>Resource manager</li>
<li>Extended machine</li>
</ul>
<p>Speaker Notes: ON SCREEN</p>

<p>The OS has two primary jobs: [CLICK]</p>

<p>Resource Manager and [CLICK]</p>

<p>To provide an extended machine to the user. [CLICK]</p>

<p>Let’s begin with OS as a resource manager.</p>

<p>[CLICK – Next Slide]</p>

<h2>OS as a Resource Manager</h2>
<dl>
<dt>Process Manager</dt>
<dd>Next program to be<br>executed? Time to be given to each program?</dd>
<dt>Memory Manager</dt>
<dd>Best use of memory to run as many programs as possible</dd>
<dt>I/O Device (e.g., Printer) Manager</dt>
<dd>Which program should use a particular I/O device?</dd>
</dl>
<p>Speaker Notes: OFF SCREEN</p>

<p>As a Resource Manager, the OS works as: [CLICK]</p>

<p>A Process Manager: Typically, considering modern interactive OSs, such as the ones we use in our laptops and desktops, multiple programs and processes alternate execution every second. The OS switches between them continuously, giving the user the illusion that those programs are executing at the same time, in parallel. In reality, each program runs for a fraction of a second and lets the next program run. [CLICK]</p>

<p>One of the jobs of the OS is to define the next program to be executed, which programs have priority, and which programs can wait. [CLICK]</p>

<p>As a Memory Manager, the OS decides what is the best use of the memory space available. It decides which programs to load to main memory, which programs to keep on fixed storage (e.g., SSD or hard drive), and which processes or programs to load into cache memory. [CLICK]</p>

<p>The OS also manages the I/O devices. It communicates to output devices such as disks, printers, and displays, and manages input such as from mouse, keyboard, camera, etc.</p>

<p>[CLICK – Next Slide]</p>
```
</chunk>

<chunk>
```html
<h2>OS as a Resource Manager</h2>
<p>(Ward, 2014)</p>
<p>Speaker Notes: ON SCREEN</p>

<p>In many ways, the OS can be compared to a one-man band that must perform each task correctly and the right time so that it can provide a good user-experience to the user.</p>

<p>[CLICK – Next Slide]</p>

<h2>What Is the <br>OS’s Job?</h2>
<ul>
<li>Resource manager</li>
<li>Extended machine</li>
<li>Provides user programs with a better, simpler, cleaner, model of the computer</li>
</ul>
<p>Speaker Notes: ON SCREEN</p>

<p>The OS also provides an extended machine to the user. This means that it hides the complexities of the underlying hardware and software, and provides users with a better, simpler, cleaner, model of the computer.</p>

<p>[CLICK – Next Slide]</p>

<h2>OS as an Extended Machine</h2>
<p>(Freedman & Morrison, 2022)<br>(Virtue, 2017)</p>
<p>OS</p>
<p>Speaker Notes: OFF SCREEN</p>

<p>For example, when we create a text file, an image, or a video, [CLICK]</p>

<p>we typically don’t think about how those bits and bytes will be stored. [CLICK]</p>

<p>All we think about is perhaps in which folder we will save the file so that we can retrieve later. [CLICK]</p>

<p>All the complexity involved with creating, naming, storing, and retrieving the file is managed by the OS.</p>

<p>[CLICK – Next Slide]</p>

<h2>OS as an Extended Machine</h2>
<table>
<tr>
<td>Beautiful interface</td>
<td>Ugly interface</td>
</tr>
</table>
<p>(Tanenbaum & Bos, 2015)</p>
<p>Speaker Notes: OFF SCREEN</p>

<p>A good analogy is provided by Tanenbaum and Bos in the Modern Operating Systems book. [CLICK]</p>

<p>We can think about the OS as providing a “beautiful” interface to the users and user programs, [CLICK]</p>

<p>while dealing with the “ugly” interfaces provided by hardware components.</p>

<p>Beautiful here is related to interfaces that are easy to use and effective to humans.</p>

<p>[CLICK – Next Slide]</p>

<h2>What the OS Is Not</h2>
<ul>
<li>User Interface
<ul>
<li>UI is just another program.</li>
</ul></li>
<li>System Tools
<ul>
<li>Tools are programs to facilitate the development of programs and manage systems.</li>
</ul></li>
<li>Libraries
<ul>
<li>Libraries are reusable packages of code.</li>
</ul></li>
</ul>
<p>Speaker Notes: ON SCREEN</p>

<p>We have talked a lot about what the OS is. Here are somethings that the OS is not: [CLICK]</p>

<p>The OS is not the user interface. We mentioned OSs such as Linux, that allow the user to switch between different operating systems. [CLICK]</p>

<p>The OS is not the System Tools. Tools that facilitate the development of programs are not part of the OS. [CLICK]</p>

<p>The OS is also not the Libraries it utilizes. Such libraries may allow the OS to function in different ways but are not part of the OS itself.</p>

<p>[CLICK – Next Slide]</p>
```
</chunk>

<chunk>
```html
<h2>OS Zoo?</h2>
<ul>
<li>Mainframe Operating Systems</li>
<li>Server Operating Systems</li>
<li>Multiprocessor Operating Systems</li>
<li>Personal Computer Operation Systems</li>
<li>Handheld Computer Operation Systems</li>
<li>Embedded Operation Systems</li>
<li>Sensor Node Operation Systems</li>
<li>Real-Time Operation Systems</li>
<li>Smart Card Operation Systems</li>
</ul>
<p>(Tanenbaum & Bos, 2015)</p>
<table>
<tr>
<td>Interactive OSs</td>
<td>Prioritize user response time</td>
</tr>
<tr>
<td>Batch OSs</td>
<td>Run large sets of tasks or jobs</td>
</tr>
<tr>
<td>Real Time OSs</td>
<td>Have well defined task priorities</td>
</tr>
</table>
<p>Speaker Notes: OFF SCREEN</p>

<p>While we, most of the time, refer to OSs as the software that runs on our laptops and desktops, the term refers to a family of OSs that perform similar jobs.</p>

<p>While the list is vast, consisting of OSs for mainframes, servers, handheld, real-time systems, etc., we can classify OSs into three large groups: [CLICK]</p>

<p>Interactive OSs: such as the ones we use in our desktops and laptops. These systems prioritize user response time. If the user interacts, the OS must give immediate, friendly feedback. [CLICK]</p>

<p>Batch OS: These systems are optimized to run typically large sets of tasks or jobs. They prioritize the completion of pre-defined queued tasks instead of user interaction. The user may have to wait for a job to finish to be able to interact or receive feedback from the system. [CLICK]</p>

<p>Real-time OSs: These specialized operating systems typically have well defined task priorities. The avionics system of an airplane, or safety systems of a car may run real-time OSs, that primarily must react/provide feedback within well defined time constraints.</p>

<p>[CLICK – Next Slide]</p>

<h2>Operating System Generations</h2>
<p>There exists a mapping of operating system generations to computer generations.</p>
<ul>
<li>Generation 1: 1945 – 1955</li>
<li>Generation 2: 1955 – 1965</li>
<li>Generation 3: 1965 – 1980</li>
<li>Generation 4: 1980 – Present</li>
<li>Generation 5: 1990 – Present</li>
</ul>
<p>Speaker Notes: ON SCREEN</p>

<p>Toward understanding how OSs evolved overtime, classifications have been created.</p>

<p>OSs have been classified into 5 Generations. These generations are often closely related to the evolution of the software of OSs and the hardware they ran on. [CLICK]</p>

<p>Let’s look at the first three generations in detail.</p>

<p>[CLICK – Next Slide]</p>

<h2>Generation 1: Vacuum Tubes and Plugboards</h2>
<p>1945 – 1955</p>
<ul>
<li>Programmer / user = operator</li>
<li>Single application program at a time – no OS</li>
</ul>
<p>(Weik, 1961)</p>
<table>
<tr>
<td>Remmington Rand 409 (Univac)</td>
<td>Plugboard</td>
</tr>
</table>
<p>(Columbia University, 2001)</p>
<p>Speaker Notes: OFF SCREEN</p>

<p>The first generation goes from 1945 until 1955.</p>

<p>While there were computers prior to 1945, this date was chosen since computers from this era share similarities with hardware and software we still use to this date. [CLICK]</p>

<p>Computers of this era were not reliable. Besides knowledge about programming, users had also to learn how to keep the machine running. In later generations, these two tasks were divided between the “programmer”, who knew how to create software for the computer, and the “operator”, who knew how to load programs and maintain the machine working. [CLICK]</p>

<p>So, Generation 1 is said to be characterized by having the users of the computers also be their operators (users wrote the code, loaded into the machines, and maintained the machines). [CLICK]</p>

<p>To program computers of this era, users/programmers used plugboards. Programs were represented by wiring instructions into physical boards that were than connected to the computer. [CLICK]</p>

<p>Another characteristic of Gen 1 computers is that they ran a single program at a time, that were small, and simple compared to today’s standards.</p>

<p>[CLICK – Next Slide]</p>
```
</chunk>

<chunk>
```html
<h2>Generation 1: Vacuum Tubes and Plugboards</h2>
<p>1945 – 1955</p>
<ul>
<li>Programmer / user = operator</li>
<li>Single application program at a time – no OS</li>
</ul>
<p>(Fischer, 2008)</p>
<table>
<tr>
<td>Vacuum tubes</td>
<td>IBM650</td>
</tr>
</table>
<p>(Cushing Memorial Library and Archives, 2009)</p>
<p>Speaker Notes: OFF SCREEN</p>

<p>One reason why computers were unreliable is that the hardware was primitive. [CLICK]</p>

<p>For example, Logic ports were implemented using Vacuum tubes.</p>

<p>Vacuum tubes required constant maintenance, work within narrow temperature ranges and are prone to failure.</p>

<p>A big part of an operator’s job was to replace or fix vacuum tubes when they failed. [CLICK]</p>

<p>Because of the low reliability, commercial computers were rare. They were mostly deployed in military facilities and research institutes. A famous exemplar of that era is the IBM 650 computer.</p>

<p>[CLICK – Next Slide]</p>

<h2>Generation 1: Vacuum Tubes and Plugboards</h2>
<p>1945 – 1955</p>
<ul>
<li>Programmer / user = operator</li>
<li>Single application program at a time – no OS</li>
</ul>
<p>(Mahlum, 2008)</p>
<table>
<tr>
<td>IBM 650</td>
<td>Perforated cards</td>
</tr>
</table>
<p>(Reinhold, 2006)</p>
<p>Speaker Notes: OFF SCREEN</p>

<p>By the end of this generation, Perforated cards began to be used. While they do not characterize this generation, perforated cards allowed in increase in program complexity since they replaced the plugboards. [CLICK]</p>

<p>It was now possible to write programs on cards and have machines read them in instead of using plugboards.</p>

<p>[CLICK – Next Slide]</p>

<h2>Generation 2: Transistors and Batch Systems</h2>
<p>1955 – 1965</p>
<table>
<tr>
<td>Transistors</td>
</tr>
</table>
<p>(Elliot, 2011)</p>
<p>Speaker Notes: OFF SCREEN</p>

<p>Generation 2 (1955 – 65): Transistors and batch systems [CLICK]</p>

<p>Hardware-wise, computers began be constructed using Transistors. Compared to vacuum tubes, transistors are reliable and much faster. Commercial mainframes became more popular and were purchased by large companies.</p>

<p>[CLICK – Next Slide]</p>
```
</chunk>

<chunk>
```html
<h2>Generation 2: Transistors and Batch Systems</h2>
<p>1955 – 1965</p>
<ul>
<li>Users were able to execute sequences of programs called “batches”.</li>
</ul>
<table>
<tr>
<td>Early batch system</td>
</tr>
</table>
<p>(IBM, 2022)</p>
<ul>
<li>OS was necessary.</li>
<li>The role of the “programmer” <br>became well defined.</li>
<li>The user was not the operator.</li>
</ul>
<p>Speaker Notes: OFF SCREEN</p>

<p>The image shows a typical system of the era. [CLICK]</p>

<p>With the evolution in hardware, users were able to execute sequences of programs in the computers. These sequences of programs were called “batches.” [CLICK]</p>

<p>Operating Systems were necessary. Their job was to load, execute and save the results of one program and do the same for the next until the batch job was finished. [CLICK]</p>

<p>The role of the “programmer” became well defined. Programmers did not know how to “fix” the machine or keep it running and were not typically responsible for loading programs into it or operating the computer. [CLICK]</p>

<p>Operators would receive perforated cards from programmers and load them into the machine for execution. It may sound strange to us, but a programmer of that era might not interact with the computer at all.</p>

<p>[CLICK – Next Slide]</p>

<h2>Generation 2 is characterized by:</h2>
<h2>Generation 2: Transistors and Batch Systems</h2>
<p>1955 – 1965</p>
<ul>
<li>Computers built with transistors that were more reliable than Gen1.</li>
<li>Batch systems that run sequences of programs.</li>
<li>Systems with rudimentary OSs.</li>
<li>Users/programmers who were not operators.</li>
</ul>
<p>Speaker Notes: OFF SCREEN</p>

<p>So, Generation 2 is characterized by: [CLICK]</p>

<p>Computers built with transistors were more reliable than Gen1. [CLICK]</p>

<p>Batch systems that run sequences of programs. [CLICK]</p>

<p>Systems had rudimentary OSs. [CLICK]</p>

<p>Users/programmers were not Operators</p>

<p>[CLICK – Next Slide]</p>
```
</chunk>

<chunk>
```html
<h2>Generation 2: Transistors and Batch Systems</h2>
<p>1955 – 1965</p>
<p>(Semantic Scholar, 2022)</p>
<table>
<tr>
<td>(a) Programmers bring cards to 1401</td>
</tr>
<tr>
<td>(b) 1401 reads batch of jobs onto tape</td>
</tr>
<tr>
<td>(c) Operator carries input tape to 7094</td>
</tr>
<tr>
<td>(d) 7094 does computing</td>
</tr>
<tr>
<td>(e) Operator carries output tape to 1401</td>
</tr>
<tr>
<td>(f) 1401 prints output</td>
</tr>
</table>
<p>Speaker Notes: OFF SCREEN</p>

<p>A typical system of this generation would be composed of input unity, processing unity, and output unity. [CLICK]</p>

<p>Magnetic tapes were typically used for storage. [CLICK]</p>

<p>Perforated cards were typically used for input, [CLICK]</p>

<p>while a printing unit would generate the output. [CLICK]</p>

<p>Once the batches of programs were loaded, there was no interaction with users. Users had to wait until the execution finished to read the output.</p>

<p>[CLICK – Next Slide]</p>

<h2>Generation 2: Transistors and Batch Systems</h2>
<h2>Generation 2A: Uniprogrammed</h2>
<table>
<tr>
<td>OS</td>
</tr>
<tr>
<td>Job 1</td>
</tr>
<tr>
<td>OS</td>
</tr>
<tr>
<td>Job 2</td>
</tr>
<tr>
<td>OS</td>
</tr>
<tr>
<td>Job N</td>
</tr>
<tr>
<td>…</td>
</tr>
<tr>
<td>Read</td>
</tr>
<tr>
<td>Process</td>
</tr>
<tr>
<td>Write</td>
</tr>
</table>
<p>Limitation: Large portions of time idle time on I/O (e.g., writing on a tape or other device)</p>
<p>!</p>
<p>Speaker Notes: OFF SCREEN</p>

<p>Generation 2 is divided into 2a and 2b. [CLICK]</p>

<p>Generation 2a: Each program on a batch (set of programs to execute), would complete before another one was loaded into the system for execution.</p>

<p>Programs had typically 3 steps: [CLICK]</p>

<p>Read data from tapes, [CLICK]</p>

<p>Process the data using the CPU, [CLICK]</p>

<p>and Write the results. [CLICK]</p>

<p>The majority of the time was spent either reading data or writing data, with large portions of time in which the CPU was idle, not performing any useful task.</p>

<p>This setup is defined as “Uniprogrammed Batch Systems” since there is a single program running at any given time.</p>

<p>A program in execution is either reading, processing or writing. The other programs in the batch must wait the completion of the previous program to begin execution.</p>

<p>[CLICK – Next Slide]</p>
```
</chunk>

<chunk>
```html
<h2>Generation 2: Transistors and Batch Systems</h2>
<h2>Generation 2B: Multiprogrammed</h2>
<table>
<tr>
<td>OS</td>
</tr>
<tr>
<td>Job 1</td>
</tr>
<tr>
<td>OS</td>
</tr>
<tr>
<td>Job 2</td>
</tr>
<tr>
<td>OS</td>
</tr>
<tr>
<td>Job N</td>
</tr>
<tr>
<td>…</td>
</tr>
<tr>
<td>Read</td>
</tr>
<tr>
<td>Process</td>
</tr>
<tr>
<td>Write</td>
</tr>
</table>
<p>Limitation: No user interaction</p>
<p>!</p>
<p>Multiprogramming keeps the CPU busy at all times.</p>
<p>Speaker Notes: OFF SCREEN</p>

<p>Generation 2b is characterized by Multiprogrammed systems. [CLICK]</p>

<p>The aim is to keep the CPU busy at all times.</p>

<p>This is accomplished by utilizing a pipeline approach. [CLICK]</p>

<p>While one program is writing, [CLICK]</p>

<p>another may be executing and yet another may be read. So, a pipeline is formed.</p>

<p>The OS is a little more complex, since it must manage multiple programs in different phases of execution. But overall performance of the system is increased. [CLICK]</p>

<p>One limitation of this system is that there was no interaction with the user. After loading a batch, all users could do was to wait to see the printed results of the execution.</p>

<p>[CLICK – Next Slide]</p>

<h2>Generation 3: Ics and Multiprogramming</h2>
<p>1965 – 1980</p>
<table>
<tr>
<td>Integrated circuits</td>
</tr>
</table>
<p>(Elliot, 2011)</p>
<p>Allowed for miniaturization, performance and even greater reliability</p>
<p>Software developed directly using terminals</p>
<p>Speaker Notes: OFF SCREEN</p>

<p>Generation 3 (1965-80) [CLICK]</p>

<p>This generation is characterized by computers built with Integrated Circuits and users that were operators. [CLICK]</p>

<p>Integrated Circuits allowed for miniaturization, performance and even grater reliability. [CLICK]</p>

<p>Users/programmers developed software directly using terminals.</p>

<p>So, the figure of the operator, loading batches of perforated cards into the systems disappeared (the user is the operator!)</p>

<p>[CLICK – Next Slide]</p>
```
</chunk>

<chunk>
```html
<h2>Generation 3: Ics and Multiprogramming</h2>
<p>1965 – 1980</p>
<table>
<tr>
<td>Timesharing systems</td>
</tr>
</table>
<p>(Include Help, 2019)</p>
<p>Computers became fast enough to perform multiple tasks per second.</p>
<table>
<tr>
<td>Terminal 1</td>
</tr>
<tr>
<td>Terminal 2</td>
</tr>
<tr>
<td>Terminal 3</td>
</tr>
</table>
<p>Each user has a terminal.</p>
<p>Speaker Notes: OFF SCREEN</p>

<p>During this generation, Timesharing systems appeared. [CLICK]</p>

<p>Computers became fast enough to perform multiple tasks per second. This speed allowed large systems (mainframes) to be connected to multiple terminals where users could interact with the system, for example developing and running programs. [CLICK]</p>

<p>Each terminal/user would receive a small amount of processing time sequentially, however, that would happen multiple times per second.</p>

<p>As a result, users had the illusion of real-time interaction with the system, and the illusion that they were they were alone interacting with the system.</p>

<p>[CLICK – Next Slide]</p>

<h2>Operating System Generations</h2>
<ul>
<li>Generation 1: 1945 – 1955</li>
<li>Generation 2: 1955 – 1965</li>
<li>Generation 3: 1965 – 1980</li>
<li>Generation 4: 1980 – Present</li>
<li>Generation 5: 1990 – Present</li>
</ul>
<p>Speaker Notes: ON SCREEN</p>

<p>We will not look into the details of the last two generations since we are still living them. They are characterized by personal computers and mobile computers. Additional generations have also been proposed such as a generation of Wearable computers.</p>

<p>[CLICK – Next Slide]</p>

<h2>Ontogeny Recapitulates Phylogeny?</h2>
<p>Each new “species” of computer<br>Goes through same development as “ancestors”</p>
<p>Consequence of impermanence</p>
<p>Text often looks at “obsolete” concepts</p>
<p>Changes in technology may bring them back<br>Happens with large memory, protection hardware, disks, virtual memory</p>
<p>(Tanenbaum & Bos, 2015)</p>
<p>Speaker Notes: ON SCREEN</p>

<p>By looking at the generations of computers and operating systems we see a pattern in which limitations and constraints periodically emerge and are overcome. [CLICK]</p>

<p>Old computers had very limited memory and storage. Programmers of that era had to learn how to deal with those constraints. [CLICK]</p>

<p>As computers evolved, large amounts of memory and storage became available at lower cost. Those “old” techniques seamed obsolete. Until wearables and embedded computers became popular and those limitations and the strategies to overcome them became relevant again.</p>

<p>Put simply, it is important to learn about the strategies and approaches that surround OSs. Even if they don’t seem immediately relevant anymore, they might become in the near future.</p>

<p>[CLICK – Next Slide]</p>
```
</chunk>

<chunk>
```html
<h2>3D Virtual Social Spaces & OS</h2>
<p>Mozilla Hubs: <br>OS Generations</p>
<p><a href="https://hubs.mozilla.com/g43rmpo/os-generations">https://hubs.mozilla.com/g43rmpo/os-generations</a></p>
<p>Speaker Notes: OFF SCREEN</p>

<p>Here is a Virtual Reality room where you can see some additional content.</p>

<p>You don’t need a VR headset. All you need is your computer.</p>

<p>This is additional material, not required. But it has some interesting content regarding the history of operating systems and the 5 generations.</p>

<p>[CLICK – Next Slide]</p>

<h2>Takeaways</h2>
<ul>
<li>Describe generations of<br>operating systems and their influences</li>
<li>Analyze effects of <br>multiprogramming vs. uniprogramming</li>
<li>Identify components and central abstractions of OS</li>
</ul>
<p>Speaker Notes: ON SCREEN</p>

<p>In this lecture, we discussed some of the history of operating systems. Now, you should be able to: [CLICK]</p>

<p>Describe the generations of operating systems and their influences; [CLICK]</p>

<p>Analyze effects of multiprogramming vs. uniprogramming; and [CLICK]</p>

<p>Identify components and central abstractions of OS.</p>

<p>Thanks for watching! I’ll see you next time.</p>

<p>[CLICK – Next Slide]</p>

<h2>Thank You For Watching</h2>

<h2>References</h2>
<p>Columbia University. (2001). Image of a plugboard [Online Image]. Columbia University. <a href="http://www.columbia.edu/cu/computinghistory/plugboard.html">http://www.columbia.edu/cu/computinghistory/plugboard.html</a><br>Cushing Memorial Library and Archives, Texas A&M. (2009). Image of IBM 650 [Online Image]. Wikimedia Commons. <a href="https://commons.wikimedia.org/wiki/File:IBM_650_with_front_open.jpg">https://commons.wikimedia.org/wiki/File:IBM_650_with_front_open.jpg</a><br>Elliot, T. (2011). Image of vacuum tubes, transistors, and circuits [Online Image]. Timo Elliot. <a href="https://timoelliott.com/blog/2011/03/why-the-last-decade-of-bi-best-practice-architecture-is-rapidly-becoming-obsolete.html">https://timoelliott.com/blog/2011/03/why-the-last-decade-of-bi-best-practice-architecture-is-rapidly-becoming-obsolete.html</a><br>Fisher, D. (2008). Image of IBM vacuum tubes [Online Image]. Wikimedia Commons. <a href="https://commons.wikimedia.org/wiki/File:Ibm-tube.jpg">https://commons.wikimedia.org